const express = require('express');
const AWS = require('aws-sdk');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 80;

// ===== DynamoDB Setup =====
AWS.config.update({ region: process.env.AWS_REGION || 'us-east-1' });
const dynamodb = new AWS.DynamoDB.DocumentClient();

// Use env var if provided; default to the plural you mentioned previously
const TABLE_NAME = process.env.POMODORO_TABLE || 'PomodoroUsers';

app.use(cors());
app.use(express.json());

// ===== Health check =====
app.get('/health', (req, res) => {
  res.status(200).send('OK');
});

// ===== Serve frontend (adjust this path to your built frontend if needed) =====
app.use(express.static(path.join(__dirname, 'frontend')));

/**
 * GET /api/user?userId=...
 * - Upsert if not exists (coins=0, cycleCount=0) and return current totals
 */
app.get('/api/user', async (req, res) => {
  const userId = String(req.query.userId || '').trim();

  if (!userId) {
    return res.status(400).json({ error: 'userId query param is required' });
  }

  try {
    // Try to get
    const getParams = {
      TableName: TABLE_NAME,
      Key: { userId }
    };
    const result = await dynamodb.get(getParams).promise();

    if (result.Item) {
      return res.json({
        userId,
        coins: result.Item.coins ?? 0,
        cycleCount: result.Item.cycleCount ?? 0
      });
    }

    // If not found, create it
    const now = new Date().toISOString();
    const putParams = {
      TableName: TABLE_NAME,
      Item: {
        userId,
        coins: 0,
        cycleCount: 0,
        createdAt: now,
        updatedAt: now
      },
      ConditionExpression: 'attribute_not_exists(userId)'
    };

    try {
      await dynamodb.put(putParams).promise();
    } catch (e) {
      // If a race creates it first, just continue
    }

    return res.json({ userId, coins: 0, cycleCount: 0 });
  } catch (error) {
    console.error('DynamoDB GET/PUT error:', error);
    return res.status(500).json({ error: 'Error fetching or creating user' });
  }
});

/**
 * POST /api/earn
 * Body: { userId: string, amount?: number }
 * - Atomically increments coins by `amount` (default 5) and cycleCount by 1
 */
app.post('/api/earn', async (req, res) => {
  const userId = String(req.body?.userId || '').trim();
  const amount = Number(req.body?.amount ?? 5);

  if (!userId) {
    return res.status(400).json({ error: 'userId is required in request body' });
  }
  if (!Number.isFinite(amount) || amount <= 0) {
    return res.status(400).json({ error: 'amount must be a positive number' });
  }

  try {
    const now = new Date().toISOString();

    const updateParams = {
      TableName: TABLE_NAME,
      Key: { userId },
      UpdateExpression: `
        SET coins = if_not_exists(coins, :zero) + :amt,
            cycleCount = if_not_exists(cycleCount, :zero) + :one,
            updatedAt = :now,
            createdAt = if_not_exists(createdAt, :now)
      `,
      ExpressionAttributeValues: {
        ':zero': 0,
        ':amt': amount,
        ':one': 1,
        ':now': now
      },
      ReturnValues: 'ALL_NEW'
    };

    const out = await dynamodb.update(updateParams).promise();
    return res.json({
      userId,
      coins: out.Attributes?.coins ?? 0,
      cycleCount: out.Attributes?.cycleCount ?? 0
    });
  } catch (error) {
    console.error('DynamoDB UPDATE error:', error);
    return res.status(500).json({ error: 'Error updating user totals' });
  }
});

// ===== (Optional) Keep your old endpoints working for now =====
// GET /api/coins -> returns only coin total (backward compat)
app.get('/api/coins', async (req, res) => {
  const userId = String(req.query.userId || 'test-user-123');
  try {
    const result = await dynamodb.get({ TableName: TABLE_NAME, Key: { userId } }).promise();
    const coins = result.Item ? (result.Item.coins ?? 0) : 0;
    res.json({ coins });
  } catch (error) {
    console.error('DynamoDB GET error (coins):', error);
    res.status(500).json({ error: 'Error fetching coins' });
  }
});

// POST /api/add-coins -> increments coins only (backward compat)
app.post('/api/add-coins', async (req, res) => {
  const userId = String(req.headers['x-user-id'] || 'test-user-123');
  const coinsToAdd = Number(req.body.coins || 0);

  if (!Number.isFinite(coinsToAdd) || coinsToAdd <= 0) {
    return res.status(400).json({ error: 'coins must be a positive number' });
  }

  try {
    const result = await dynamodb.update({
      TableName: TABLE_NAME,
      Key: { userId },
      UpdateExpression: 'SET coins = if_not_exists(coins, :zero) + :coins',
      ExpressionAttributeValues: { ':coins': coinsToAdd, ':zero': 0 },
      ReturnValues: 'UPDATED_NEW'
    }).promise();

    res.json({ coins: result.Attributes.coins });
  } catch (error) {
    console.error('DynamoDB UPDATE error (add-coins):', error);
    res.status(500).json({ error: 'Error updating coins' });
  }
});

// ===== Fallback route for SPA =====
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'frontend', 'index.html'));
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
